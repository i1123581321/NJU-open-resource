# Simple-Typed Lambda Calculus

为 lambda calculus 添加形式化的类型系统

## Type System

### Basic

基本尝试：使用函数的参数和返回类型来定义函数类型，函数体内的 free variable 的类型需要依据上下文而定，即 context

对于 STLC (Simple-Typed Lambda Calculus) 来说，定义类型为
$$
\tau, \sigma ::= T \mid \sigma \to \tau
$$
T 为基本类型（如 int），而 $\tau \to \sigma$ 为函数，其中 $\to$ 是右结合的

同时也需要扩充 lambda term 原本的定义
$$
M, N ::= x \mid \lambda x:\tau . M \mid M \; N
$$
Reduction rules 同理

Typing judgment 是对 term 分配类型的语句，形如
$$
\Gamma \vdash M:\tau
$$
语义为：在上下文 $\Gamma$ 下，M 是一个类型为 $\tau$ 的**良类型** term

其中 $\Gamma$ 是 typing context，其定义为
$$
\Gamma ::= \cdot \mid \Gamma, x:\tau
$$
对于有 free variable 的 term 来说，$\Gamma$ 中包含了所有 free variable 的信息，而对于 closed term 来说，$\Gamma$ 为空（即 $\cdot$）

$\vdash$ 表示推导，即根据 context 推导类型信息

则有以下基本的 Typing rules
$$
\begin{gathered}
\frac{}{\Gamma, x:\tau \vdash x: \tau}\\
\\
\frac{\Gamma \vdash M:\sigma \to \tau \quad \Gamma \vdash N:\sigma}{\Gamma \vdash M \; N:\tau}\\
\\
\frac{\Gamma, x:\sigma \vdash M:\tau}{\Gamma \vdash (\lambda x:\sigma. M):\sigma \to \tau}
\end{gathered}
$$

### Soundness and Completeness

定义 sound 和 complete 为

* sound：系统不会接受错误的程序，没有假阴性，sound type system 称为 type-safe
* complete：系统不会拒绝正确的程序，没有假阳性

但是对于任何图灵完备的编程语言来说，会出错的程序的集合是不可判定的，因此类型系统不能做到同时满足 sound 和 complete

因此实践中的做法是选择 soundness，同时尽可能减少 false positive

soundness 满足
$$
\cdot \vdash M:\tau \land M \to^{*} M^{\prime} \implies \cdot \vdash M^{\prime} : \tau \land (M^{\prime} \in \text{Values} \lor \exists M^{\prime\prime}. M^{\prime} \to M^{\prime\prime})
$$
即对于一个良类型的 term 进行 reduction，结果只有两种可能：或者其能继续推导，或者停止在一个值上（值的定义是语言的语义决定的，对于 lambda calculus 来说 lambda abstraction 和 constant 都是值），且推导过程中类型不变

soundness 的定义基于两个基本的引理

* preservation：良类型的 term 只会推导到同样类型的良类型 term，即 $\cdot \vdash M:\tau \land M \to M^{\prime} \implies \cdot \vdash M^{\prime} :\tau$
* progress：良类型的 term 或是值或是能继续推导，即 $\cdot \vdash M:\tau \implies M \in \text{Values} \lor \exists M^{\prime}.M \to M^{\prime}$

由于良类型的 term 推导一定会停止，故形如 ($\lambda$x. x x) ($\lambda$x. x x) 的 term 无法得出其类型

