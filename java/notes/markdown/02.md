# 02

On Java 第六、十、十一章的阅读笔记，主要内容是面向对象的进阶

## 初始化和清理

初始化和清理是两个主要的安全性问题

### 构造器

通过构造器保证每个对象被正确初始化，确保在用户使用对象前构造器被调用。构造器可以是无参或者带参数的。

构造器没有返回值。

无参构造器是不接受参数的构造器，如果类没有提供构造器，编译器会创建一个无参构造器，但是如果显式定义了一个构造器，编译器就不会提供默认的无参构造器了

### 方法重载

重载产生原因之一就是需要以不同方式创建对象，而构造器的名称是唯一的。重载允许方法有相同的名称和不同的参数列表，但是不能根据返回类型的不同来重载

重载时基本类型会从较小的类型自动转换到较大的类型

不能通过返回值来重载的原因是有很多情况调用函数时会忽视返回值

### this 关键字

调用方法时会隐式地传入一个参数 this，它代表了指向当前操作对象的一个引用。this 只能在非静态方法中使用

一般只在需要 this 的情况下使用 this

在构造器中调用其他构造器时（一般是为了代码复用），可以使用 this 引用

### 垃圾回收器

Java 可以在类中定义 `finilaze()` 方法，用于清理，当垃圾回收器准备回收对象内存时会先调用该方法，然后在下一轮垃圾回收时回收内存。需要注意的是对象可能不会被回收，垃圾回收也不等于析构。如果程序没有接近耗尽内存，则 GC 不会发生，而是等程序结束直接将分配的内存归还给 OS

`finalize()` 主要发生在处理不是被 `new` 出来的对象（否则会被 GC 处理），这种情况一般发生在调用本地方法的情况下

如果希望进行释放内存以外的清理工作，必须显式地进行，因为 GC 不一定会发生

但是 finalize 可以用于验证对象的终结条件，即被回收前必须满足的一些条件，如果在 finalize 时这些条件没有被满足，则可以抛出异常

Java 的 GC 是自适应的，具体实现取决于虚拟机，如典型的标记-清扫方法

Java 有提升性能的 JIT（Just-In-Time）技术，即将程序部分或全部地编译为本地机器码，这样就比 JVM 执行要快了

### 成员初始化

对于类中的基础类型成员，Java 在初始化时为其提供默认值，如果是对象引用，会默认置为 `null`

对于成员初始化，最直接的方法就是在成员的定义处初始化

也可以通过函数对成员进行初始化，只要保证不会在成员变量初始化前引用其即可

### 构造器初始化

可以在构造器中对成员进行初始化，但是这是在成员初始化之后进行的。成员初始化的顺序取决于他们在类中定义的文本顺序

静态数据的初始化发生在类的加载时，即第一次访问类的静态成员时。静态初始化只会在加载时初始化一次

初始化的过程可以总结为

* 首次创建对象时在 CLASSPATH 中查找到类对应的 class 文件
* 将其加载后（得到一个 class 对象），执行所有静态初始化的动作
* 使用 `new` 创建对象时，在堆上分配足够内存
* 分配的空间初始化为 0，这样基本类型数据设置为默认值，对象引用设置为 null
* 执行出现在字段定义处的初始化
* 执行构造器

### 静态初始化

可以显式地把静态初始化放在一段代码块里

```Java
public class Spoon {
    static int i;

    static {
        i = 47;
    }
}
```

其中的代码等同于静态初始化，只会执行一次

### 实例初始化

对于非静态变量，也可以执行初始化块，如

```Java
public class Mugs {
    Mug mug1;
    Mug mug2;
    { // [1]
        mug1 = new Mug(1);
        mug2 = new Mug(2);
        System.out.println("mug1 & mug2 initialized");
    }
}
```

这一部分初始化也是在构造器调用之前完成的

### 数组初始化

数组引用定义时不能指定数组大小

花括号初始化只能在定义时使用

```java
int[] a1 = {1, 2, 3, 4, 5};
```

如果在编写代码时不确定数组元素个数，可以使用 `new` 关键字创建动态数组，如果数组元素是基本类型，其值会自动设置为默认值

```java
int[] a = new int[rand.nextInt(20)];
```

如果创建的是非基本类型的数组，则数组中的元素类型是引用，如果不初始化就使用会报异常

可以以一种更方便的花括号初始化来初始化数组

```java
Integer[] b = new Integer[] {1, 2,3,};
```

这种初始化不限定在定义处使用

可变参数列表会将任意个的参数打包为数组传入

```java
static void printArray(Object... args) {
    for (Object obj: args) {
    	System.out.print(obj + " ");
    }
    System.out.println();
}
```

如果一个函数只有可变参数列表，会在重载时带来问题（当没有参数传入时编译器不知道选择哪一个），此时可以通过给函数添加非可变参数来区分

### 枚举类型

枚举类型通过 `enum` 关键字创建，枚举对象有一些很方便的方法，如 `toString()` 显示实例名称，`ordinal()` 返回序数，`static values()` 返回所有枚举常量的数组

`enum` 本质是类，展现出来的行为是编译器造成的