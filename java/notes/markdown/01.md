# 01

On Java 8 第一、三、七、八、九章的阅读笔记，主要内容是面向对象的基础

## 对象

### 面向对象思想

面向对象在问题空间建模，然后映射到解空间，是一种更加强大的抽象方式

面向对象的基本特征是

* 万物皆对象
* 程序是一组对象，对象间进行消息传递
* 每个对象有自己的存储空间，可以容纳其他对象
* 每个对象都有类型
* 同一类的对象能接受相同的消息

对象能接受的消息是通过接口定义的，对象的类型规定了其接口

通过封装来划清服务提供者和服务使用者之间的界限，而接口确保了双方的一致性

### 复用代码

面向对象的程序有两种基本的复用方式

* 组合（Composition）：即一个对象拥有另一个对象，两者生命周期相同，且不与其他对象共享
* 聚合（Aggregation）：动态组合，拥有者和被拥有者生命周期不同，可以多个对象共享一个对象

组合和聚合极大地丰富了类型系统

继承也是复用代码的机制之一，从基类派生出的类型和基类有相同的行为，也可以扩展出自己独有的行为

继承也有两种情况

* 子类重写了父类的方法，但没有扩展接口，这种情况称为 is-a 关系，两者可以完美替代
* 子类还扩展了接口，这种情况称为 is-like-a 关系

Java 是单继承的，所有类型都派生自 `Object`

### 多态

处理类的基类而非具体类，可以编写出更通用的代码，这种行为称为多态

OOP 的程序直到运行时才能确定具体调用的代码的地址，即动态绑定。多态是使用动态绑定实现的

在 Java 中，动态绑定是默认行为

### 对象的创建与生命周期

Java 将对象的引用保存在栈上，对象本身则位于堆。Java 使用动态内存分配，使用 GC 来防止内存泄漏

Java 的单继承机制也为 GC 带来了方便

## 万物皆对象

Java 中使用对象的引用来操作对象，初始化一个对象的引用不代表关联了一个对象实例，一个良好的习惯是创建引用的同时进行初始化

### 创建对象

Java 中使用 `new` 关键字创建新的对象

一般的对象创建后保存在堆内，其引用则存在与栈上，但是也有例外——基本类型

Java 的基本类型之间存储在栈上，且其占据的大小是平台无关的。如果想在堆中保存基本类型，就要使用其包装类

```java
char c = 'x';
Character ch = new Character(c);
```

Java 会进行自动的装箱和拆箱

```java
Character ch = 'x';
char c = ch;
```

Java 也提供了两个类 `BigInteger` 和 `BigDecimal` 来执行高精度的计算

### 对象清理

Java 的变量只有在作用域内才可用，而对象则不同，对象的生命周期可以超过创建其的作用域，只有在其不可达时（没有指向该应用的引用），该对象的生命周期才会结束

Java 的自动垃圾回收使得内存分配和使用不再需要程序员操心

### 类的创建

类通过 `Class` 关键字定义，其中可以包括两种类型的元素

* 方法（method）
* 字段（field）

通常同一类的对象共享方法，但保存各自的字段。字段可以是基本类型或引用类型

Java 通过关键字来控制对类成员的访问

* `public` 对外可见
* `private` 对外不可见
* `protected` 对外不可见，但是对继承的子类可见
* `default`，即无关键字，在整个包内可见

如果类的字段是基本类型，在初始化类时会被赋予初始值，但是仍然推荐显式初始化类字段

### 方法

方法是类的一部分，只能被对象调用

方法的名和参数列表构成了方法的签名（signature），这是方法唯一的标识

传递参数时 Java 以**值传递**的方式传递对象的引用。如果不想返回值可以定义返回类型为 `void`，除此之外的情况必须显式指明返回值，否则会产生编译时错误

### static 关键字

`static` 关键字定义的字段或方法不依赖与特定的对象实例，而是类所属的

一般推荐使用类名直接引用静态的对象/方法，为了强调其静态属性

## 封装

面向对象中基本的问题：如何区分变与不变的事物

Java 提供了访问修饰符，用于指明库的开发者哪些对使用者是可见的，而哪些是不可见的

一般来说权限是 public > protected > package access > private

而将库的组件集中到一个单元是通过 `package` 关键字实现的

### 包

包可以包含一组类，其被组织在一个单独的名空间内

使用包内的类需要显式导入 `import`

每个 Java 源代码文件被称为一个编译单元，其中可以有一个 public 类，其名称必须和文件名相同，其余类在包外是访问不到的

一般包的组织就是文件系统中目录的组织，必须完全一致否则会找不到类

导入重复的名称时必须显式指明，否则会报错

### 访问权限修饰符

Java 有三种访问权限修饰符 `public/protected/private`，可以修饰类名，属性名，方法名

不使用修饰符就是包访问权限（package access），同一包内可以任意访问，如果不显式指明包，Java 会认为同一目录下的文件属于一个默认的包

public 就是接口的访问权限，所有人都可以访问

private 是无法访问的内容，将不希望暴露的内容标记为 private 可以减少误操作的可能性，属性尽量全设置为 private

protected 是继承访问权限

一个包访问权限的类的 public 构造器是没有意义的，在包外并不能访问到

访问控制机制实现了封装，将接口与实现分离

### 类访问权限

类要么是 public，要么是包访问权限，其他情况是没有意义的

每个编译单元只能有一个 public 类，且必须与编译单元文件名相同

控制类的实例化可以将构造器设为 private 且使用静态方法提供实例

## 复用

复用有两种主要方式

* 在新类中创建现有对象，即组合（Composition），复用代码的功能而非形式
* 创建现有类类型的新类，即复用了现有类的形式，称为继承（Inheritance）

### 组合

将对象的引用作为新类的字段，即可实现组合

虽然基本类型的字段有默认值，但引用没有默认对象。初始化引用有四种方式

* 定义时初始化，早于构造函数
* 构造函数中初始化
* 延迟初始化，即使用对象时再初始化（使用前先判断引用是否为空）
* 实例初始化，包括实例变量初始化和实例初始化块，后者可以执行类似循环之类的复杂操作

> Java 初始化顺序
>
> 1. 设置成员变量为默认值
> 2. 调用构造方法（但不执行）
> 3. 执行父类构造方法
> 4. 实例初始化和初始化块
> 5. 执行构造方法体

### 继承

创建类总是会继承，不显式继承现有类就是隐式继承 `Object`

继承使用关键字 `extends`，继承的子类会获得基类所有的方法和成员，也可以定义自己的新方法

构造子类实例的时候从基类开始，如果没有无参的基类构造器，就需要用 `super` 关键字引用基类显式调用构造器，并且构造必须在子类构造器第一行

Java 可以间接实现委托（Delegate），介于组合（在新类中保留其实例引用）和继承（新类有和原来的类一样的接口）之间

> 委托者保存被委托者的实例引用
>
> 实现被委托者的接口
>
> 将对被委托者的接口调用转发给被委托者的实例

可以定义一些回收前的清理方法，调用清理方法要按创建的反向顺序，即先清理，然后调用基类的清理方法，显式清理用于解决一些 GC 无法处理的情况

重载不等于重写，在子类中重载基类的同名方法不会覆盖基类的方法，所以最好给重写加上注解 `@Override`，以避免意外的重载

### 组合和继承的选择

想要使用已有类的功能，使用组合。将其声明为 public 可以实现部分委托的功能（这种情况并不多见，总的来说属性应当声明为 private）

继承用于表达 is-a 关系，在十分需要向上转型（up-casting）时才考虑使用继承

继承重要的方面不是使新类获得方法（使用组合就可以实现这一点），而是继承表明了新类也是基类的一种类型，可以将派生类的引用转换为基类的引用，这种行为称为向上转型，是多态的基础。向上转型永远是安全的，因为只可能减少已有的方法，而不会增加没有的方法

并不推荐在 OOP 中滥用继承

### final 关键字

final 关键字一般可以用于修饰数据，方法和类

#### final 数据

final 数据不会被修改，使用 final 修饰基本类型变量会使其值不再改变，而如果修饰对象引用只会使其不再指向其他对象，而不能防止对象实例被修改

同时使用 static 修饰会使其只占据一段内存（如果不使用则是每个对象实例都有一段不能改变的内存空间，各自独立）

只有带有恒定初始值的 final 变量才能称为编译时常量，其他情况变量的值都不是编译时可得知的

如果 final 数据没有在定义时初始化则必须在构造器里初始化，保证使用前已经被初始化

如果 final 修饰参数，则说明不能在函数中改变参数的值

#### final 方法

final 方法可以防止方法被重写

所有 private 的方法都是隐式 final 的，因为不能访问所以无从复写

可以在派生类中定义和基类 private 方法签名一样的方法，但这并不是重写，因为只有基类暴露出来的接口才能被重写，而 private 方法不是接口的一部分，这种情况只是创建了新方法

#### final 类

final 类不能被继承，其中所有的方法都是隐式 final 的，但是属性可以选择是否为 final

final 的使用要谨慎

### 类的初始化和加载

类在首次使用时被加载，首次使用包括创建类的第一个实例或者第一次访问类的静态属性或方法（构造器隐式 static，所以准确来说在第一次访问类的 static 成员时类被加载）

首次使用类时初始化 static 对象，按照文本顺序初始化，static 变量只被初始化一次

在继承的情况下，按照基类到派生类的顺序加载并初始化（派生类的初始化可能依赖基类的成员正确初始化），所有类被加载了才开始创建对象（创建对象的初始化过程见上）

## 多态

多态又称为动态绑定，提供了另一层面的接口和实现分离

### 向上转型

可以将一个对象视为其基类类型，这种行为称为向上转型（up-casting）

为了避免为基类的每个派生类编写一个单独的方法，一般是编写接受基类引用并且调用基类方法的方法，这样派生类的引用传入后也能视作基类引用被接受，而在编写代码时编译器是不知道具体传入的是什么类型的实例的

将方法调用和方法主体关联起来就是绑定，后期绑定即运行时进行绑定，Java 默认方法都是后期绑定，除了 static 和 final 方法（使用这一关键词也表示了不希望方法的绑定在运行时决定，可以生成更加高效的代码）

后期绑定使得面向基类编程可以得到正确的结果，这极大地增强了程序的可扩展性

静态方法不具有多态性，其与类而非对象关联

### 构造器与多态

构造器不具有多态性，因为构造器本质是隐式的静态方法

对继承对象进行构造时，顺序为

* 递归调用基类构造器直到最高层的基类
* 按声明的顺序初始化各成员
* 调用派生类构造器的方法体

如果要显式进行清理，先调用自己的清理函数，然后是基类的。如果有多个对象间的共享对象，就要进行引用计数了

如果在构造器内调用动态绑定的方法，就会调用重写后的版本，而此时派生类的部分可能还没初始化完成，这种情况会带来隐含的 bug

```java
class Glyph {
    void draw() {
        System.out.println("Glyph.draw()");
    }

    Glyph() {
        System.out.println("Glyph() before draw()");
        draw();
        System.out.println("Glyph() after draw()");
    }
}

class RoundGlyph extends Glyph {
    private int radius = 1;

    RoundGlyph(int r) {
        radius = r;
        System.out.println("RoundGlyph.RoundGlyph(), radius = " + radius);
    }

    @Override
    void draw() {
        System.out.println("RoundGlyph.draw(), radius = " + radius);
    }
}

public class PolyConstructors {
    public static void main(String[] args) {
        new RoundGlyph(5);
    }
}

/* output
Glyph() before draw()
RoundGlyph.draw(), radius = 0
Glyph() after draw()
RoundGlyph.RoundGlyph(), radius = 5
*/
```

这是因为在递归地开始调用基类构造器前，分配空间时会将内容全部置为 0，因此最好遵循规范，尽量少在构造器中调用成员方法，除了 final 方法

### 协变返回类型

派生类的重写方法可以返回基类返回类型的派生类型

### 使用继承设计

一般来说还是优先选择组合

一条通用准则是：使用继承表达行为差异，使用属性表达状态的变化

Java 如果是在运行时进行向下转型，就会检查其类型是否匹配，否则会抛出一个 ` ClassCastException`