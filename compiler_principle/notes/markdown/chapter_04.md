[![white.png](https://i.loli.net/2019/04/11/5cae134487910.png)](https://github.com/i1123581321/NJU-open-resource)

# Syntax Analysis

## 引论

文法：一种用于描述程序设计语言语法的表示方法，能够自然地描述程序设计语言构造的层次化语法结构

* 文法给出了程序设计语言的**语法规约**
* 可以基于文法构造语法分析器
* 语法分析器有助于源程序翻译代码
* 文法的扩展性有助于语言的演化

语法分析器接受词法单元序列，输出其语法树表示。一般可分为

* 通用型：没有实践性
* 自顶向下：处理 LL 文法
* 自底向上：处理 LR 文法

## 上下文无关文法（Context Free Grammar, CFG）

### Definition

> A context-free grammar $G$ is defined by the 4-tuple
> $$
> G = (V, \Sigma, R, S)
> $$
> where
>
> 1. $V$ is a finite set; each element $v \in V$ is called *a nonterminal character* or a *variable*.  Each variable defines a sub-language of the language defined by $G$
> 2. $\Sigma$ is a finite set of *terminals*, disjoint from $V$, which make up the actual content of the sentence. The set of terminals is the alphabet of the language defined by the grammar $G$
> 3. $R$ is the finite relation from $V$ to $(V \cup \Sigma)^{*}$, where the asterisk represents the [Kleene star](https://en.wikipedia.org/wiki/Kleene_star) operation. The members of $R$ are called the *(rewrite) rule*s or *production*s of the grammar. (also commonly symbolized by a $P$)
> 4. $S$ is the start variable (or start symbol), used to represent the whole sentence (or program). It must be an element of $V$

### Derivations

从开始符号出发，每次将待处理串中的某个非终结符号替换为其某个产生式的体，这样的推导思路对应于**自顶向下**构造语法分析树的过程

**推导**：考虑一个文法符号序列 $\alpha A \beta$ ，其中 $A$ 为非终结符，$\alpha, \beta$ 为任意文法符号串。设 $A \to \gamma$ 是一个产生时，则推导可写作
$$
\alpha A \beta \Rightarrow \alpha \gamma \beta
$$
其中 $\Rightarrow$ 表示经一步推导出

> 经零步或多步推导出 (reflexive transitive closure)：$\overset{*}{\Rightarrow}$
>
> * 对任何串 $\alpha$ ，有 $\alpha \overset{*}{\Rightarrow} \alpha$
> * 如果 $\alpha \overset{*}{\Rightarrow} \beta, \beta \Rightarrow \gamma$ ，则 $\alpha \overset{*}{\Rightarrow} \gamma$
>
> 经一步或多步推导出 (transitive closure)：$\overset{+}{\Rightarrow}$
>
> 最左推导 (leftmost derivation)：$\underset{\text{lm}}{\Rightarrow}$ ：推导时选择最左的非终结符
>
> 最右推导 (rightmost derivation)：$\underset{\text{rm}}{\Rightarrow}$ ：推导时选择最右的非终结符，也被称为规范推导 (canonical derivation)
>
> 每一步最左推导可以写作
> $$
> w A\gamma \underset{\text{lm}}{\Rightarrow}w\delta \gamma
> $$
> 其中 $w$ 只包含终结符

句型（sentential form）：如果 $S \overset{*}{\Rightarrow} \alpha$ ，则 $\alpha$ 是文法的一个句型。句型可以包含终结符和非终结符，也可以是空串

句子（sentence）：不包含非终结符的句型

一个文法 $G$ 生成的语言是其所有句子的集合，记作 $L(G)$
$$
\omega \in L(G) \iff S \overset{*}{\Rightarrow} \omega
$$
从推导的角度看，语法分析的任务是接受一个终结符串作为输入，找出从文法的开始符号推导出这个串的方法。

### Parse tree

语法分析树（parse tree）是推导的图形表示形式，过滤了推导过程中对非终结符应用产生式的顺序。

* 根节点是文法的开始符号
* 叶子节点是非终结符，终结符或空串 $\epsilon$
* 内部节点是非终结符
* 每个内部节点表示一次产生式的应用，其标号为产生式头，子节点从左到右是产生式体

从左到右排列叶节点的符号，得到根的一个句型，称为树的结果（yield）或边缘（frontier）

parse tree 可以反应串的语法层次。

> Derivation 与 Parse tree 的关系
>
> 考虑推导过程 $\alpha_{1} \Rightarrow \alpha_{2} \Rightarrow \dots \Rightarrow \alpha_{n}$ ，对于其中每个句型 $\alpha_{i}$ ，均可构造出一个结果为 $\alpha_{i}$ 的语法树，其过程是对 $i$ 的归纳
>
> Basis. $\alpha_{1} = A$ 的语法分析树是标号为 $A$ 的单个节点
>
> Induction. 假设已经构造了结果为 $\alpha_{i-1} =X_{1}X_{2}X_{3}\dots X_{k}$ 的语法分析树，设 $\alpha_{i}$ 是将 $\alpha_{i-1}$ 中的某个符号 $X_{j}$ 替换为 $\beta = Y_{1}Y_{2}\dots Y_{m}$ 得到的句型，即对 $\alpha_{i-1}$ 应用 $X_{j} \to \beta$ ，得到 $X_{1}X_{2}\dots X_{j-1}\beta X_{j+1} \dots X_{k}$ ，则在语法分析树中找到左起第 $j$ 个非 $\epsilon$ 叶节点，向其添加 $m$ 个子节点 $Y_{1}Y_{2} \dots Y_{m}$ 。若 $\beta = \epsilon$ ，则添加一个为 $\epsilon$ 的子节点

### Ambiguity

若一个文法可以为一个句子生成多个语法分析树，则这个文法是二义性的（ambiguous）。

对于编程语言的文法，需要其无二义性。或者使用消二义性规则（disambiguating rules）来消除二义性。 e. g.

* 运算时先乘除后加减
* 没有大括号时嵌套的 if-else 结构的匹配问题

### Language Generated by a Grammar

一个文法的语言是从其开始符号出发，能推导得到的所有句子的集合。

验证文法生成的语言一般分为两部分

* 证明 $G$ 生成的每个串都在 $L$ 中
* 证明 $L$ 的每个串都可由 $G$ 生成

证明过程通常使用数学归纳法，对推导序列长度/串的长度归纳

### CFG and RE

CFG 的表达能力强于 RE，每个 RE 都可以用一个 CFG 描述，但反之不成立。

> E. g.
> $$
> L = \{a^{n}b^{n}: n \geqslant 1 \}
> $$
> 上述语言可以用 CFG 表示：
> $$
> S \to aSb \mid ab
> $$
> 但是不能用 RE 表示

RE 适合描述词法结构，CFG 适合描述嵌套结构

从一个 RE 的 NFA 可以构造一个 CFG

* 对 NFA 每个状态 $i$ ，创建非终结符 $A_{i}$
* 如果有 $i$ 在输入 $a$ 上到达 $j$ 的 transition，增加产生式 $A_{i} \to a A_{j}$
* 如果 $i$ 在输入 $\epsilon$ 上到达 $j$ ，增加产生式 $A_{i} \to A_{j}$
* 如果 $i$ 是接受状态，增加产生式 $A_{i} \to \epsilon$
* 如果 $i$ 是开始状态，令 $A_{i}$ 为开始符号

## 文法的设计

为了进行高效的语法分析，需要对文法做一定的处理，如消除二义性，消除左递归，提取左公因子等

### 消除二义性

文法的二义性是指文法可以为一个句子生成多颗不同的语法分析树，如下图的文法

![2019-09-23_23-28-03.png](https://i.loli.net/2019/09/23/im3USvIfrMcGh54.png)

在分析嵌套的 if-then-else 结构时会产生 else 与哪个 then 匹配的问题。类 C 语言的规则是每个 else 与最近尚未匹配的 then 相匹配。

可以通过改写文法消除二义性

![2019-09-23_23-28-14.png](https://i.loli.net/2019/09/23/yLznsGOISH827jd.png)

但是二义性的消除方法没有统一的规律可循，故一般不通过改变文法来消除二义性

### 消除左递归

如果一个文法中存在一个非终结符号 $A$ 使得对某个串 $\alpha$ 存在推导 $A \overset{+}{\Rightarrow}A\alpha$ ，则称这个文法是左递归（left recursive）的

**立即左递归**：形如 $A \Rightarrow A\alpha$

立即左递归可通过如下的方法消除，首先将 $A$ 的产生式分组
$$
A \to A\alpha_{1} \mid A\alpha_{2} \mid \dots \mid A\alpha_{m} \mid \beta_{1} \mid \beta_{2} \mid \dots \mid \beta_{n}
$$
其中 $\beta_{i}$ 都不以 $A$ 开头。则可以将产生式替换为
$$
\begin{align*}
\begin{array}{c}
{A \rightarrow \beta_{1} A^{\prime}\mid \beta_{2} A^{\prime}\mid \cdots \mid \beta_{n} A^{\prime}} \\
{A^{\prime} \rightarrow \alpha_{1} A^{\prime}\mid\alpha_{2} A^{\prime}\mid \cdots\mid\alpha_{m} A^{\prime}\mid\epsilon}\end{array}
\end{align*}
$$
这样做的前提是 $\alpha_{i} \neq \epsilon$

这样可以消除立即左递归，对于多步推导产生的左递归，可以通过以下的算法消除，算法要求文法中不出现**环**（形如 $A \overset{+}{\Rightarrow}A$ 的推导）或 $\epsilon$ **产生式**（形如 $A \to \epsilon$）

> 按照某个顺序将非终结符排序为 $A_{1}, A_{2}, \dots, A_{n}$
>
> $i$ 从 1 到 $n$ ，若存在 $A_{i} \to A_j \gamma, (i > j)$ ，则将其替换为
> $$
> A_{i} \to \delta_{1} \gamma \mid \delta_{2} \gamma \mid \dots \mid \delta_{k} \gamma
> $$
> 其中 $A_{j} \to \delta_{1} \mid \delta_{2} \mid \dots \mid \delta_{k}$ 是所有 $A_{j}$ 的产生式
>
> 经过这样的过程，所有形如 $A_{i} \to A_{k}\gamma$ 的产生式都满足 $k \geqslant i$ ，其中若存在 $A_{i}$ 的立即左递归则将其消除。
>
> 消除立即左递归后所有形如 $A_{i} \to A_{k}\gamma$ 的产生式满足 $k > i$ ，循环结束后不会有左递归

### 提取左公因子

提取左公因子是一种文法转换方法，可以产生适用于自顶向下语法分析技术的文法。主要用于在不清楚两个产生式中如何选择时，可以通过改写产生式来推后决定

对于一个非终结符 $A$，提取左公因子的过程如下。

找出它的多个可选项之间的最长公共前缀 $\alpha$ ，并且满足 $\alpha \neq \epsilon$ ，则将其所有的产生式
$$
A \to \alpha \beta_{1} \mid \alpha \beta_{2} \mid \dots \mid \alpha \beta_{n} \mid \gamma
$$
替换为
$$
A \to \alpha A^{\prime} \mid \gamma\\
A^{\prime} \to \beta_{1} \mid \beta_{2} \mid \dots \mid \beta_{n}
$$

## 自顶向下分析技术

自顶向下语法分析可以看作是为输入串构造一个语法分析树的问题，从语法分析树的根节点开始构造，也可以看作寻找输入串的最左推导的过程。

### 递归下降分析框架

自顶向下的语法分析技术可以通过一个递归下降的分析框架实现。

* 框架由一组过程组成，每个非终结符对应一个过程
* 程序从开始符号的过程开始
* 每个过程选择一个产生式体，扫描相应的句子，遇到非终结符则调用符号对应的过程

非终结符 $A$ 的过程可描述为

```pseudocode
void A(){
	选择一个产生式 A -> X_1 X_2 ... X_k
	for(i = 1 to k){
		if(X_i 是非终结符)
			调用 X_i
		else if(X_i 等于当前输入 a)
			读入下一个输入
		else
			错误
	}
}
```

但是在 $A$ 有不止一个产生式时，就可能需要回溯，因为当前产生式产生错误不代表其他产生式不能匹配。然而在进行语法分析时一般不回溯。通过预测分析技术配合对文法的修改可以实现不回溯而生成语法分析树

递归下降的分析过程遇见左递归时会陷入死循环，故需要**消除左递归**

> 需要一个好的方式来选择 $A$ 的产生式

### 预测分析法

预测分析技术通过在输入中向前看固定多个符号来选择正确的产生式。通常情况下只用看一个。

预测分析技术通过

* 消除二义性：避免歧义
* 消除左递归：防止递归无法退出
* 提取左公因子：查看下一个输入符号时保证满足的产生式唯一

来实现**确定性**的，**无回溯**的分析技术

> 递归下降分析一般只适合于每个子表达式的第一个终结符能够为产生式选择提供足够信息的那些文法

在实现预测分析技术时，借助两个函数 $FIRST(), FOLLOW()$ 来根据下一个输入符号确定应用哪个产生式。

当前句型为 $xA\beta$ ，而输入是 $xa$ ，则选择产生式 $A \to \alpha$ 的必要条件是下列之一

* $A \overset{*}{\Rightarrow} \epsilon$ 且 $\beta$ 以 $a$ 开头，即某个句型中 $a$ 在 $A$ 之后
* $A \overset{*}{\Rightarrow} a\dots$

当按以上两个条件选择时能保证唯一性，就可以避免回溯

#### First

$First(\alpha)$ 是可从 $\alpha$ 推导得到的串的首符号的集合，如果 $\alpha \overset{*}{\Rightarrow} \epsilon$ ，则 $\epsilon$ 也在 $FIRST(\alpha)$ 中

在预测分析时，考虑两个产生式 $A \to \alpha \mid \beta$ ，其中 $FIRST(\alpha), FIRST(\beta)$ 是不相交的集合，则只用查看下一个输入符号就可以在两个产生式之间选择

对于文法符号 $X$ 的 $FIRST(X)$ ，不断应用下列规则直至没有终结符或 $\epsilon$ 可加入为止

* 如果 $X$ 是终结符，$FIRST(X) = \{X\}$
* 如果 $X$ 是非终结符，且有规则 $X \to a\dots$ ，则将 $a$ 添加到 $FIRST(X)$ 
* 如果 $X \to \epsilon$ ，将 $\epsilon$ 加入 $FIRST(X)$
* 如果 $X$ 是非终结符且有产生式 $X \to Y_{1}Y_{2}\dots Y_{k}$ 
  * 如果对某个 $i$ ，$a$ 在 $FIRST(Y_{i})$ 且 $\epsilon$ 在所有的 $FIRST(Y_{1}), FIRST(Y_{2}), \dots , FIRST(Y_{i-1})$ 中，则 $a$ 在 $FIRST(X)$。
  * 即 $FIRST(Y_{1})$ 的符号都在 $FIRST(X)$ ，而若 $Y_{1} \overset{*}{\Rightarrow} \epsilon$ ，则将 $FIRST(Y_{2})$ 也加入 $FIRST(X)$ ，以此类推。
  * 只有在对所有 $j = 1, 2, \dots, k$ 均有 $\epsilon \in FIRST(Y_{j})$ 时，才将 $\epsilon$ 加入 $FIRST(X)$

对于一个文法符号串 $X_{1}X_{2}\dots X_{n}$ ，计算 $FIRST(X_{1}X_{2}\dots X_{n})$ 的过程同理，首先将 $F(X_{1})$ 加入，若 $\epsilon$ 在 $FIRST(X_{1})$ ，则再加入 $FIRST(X_{2})$ ，以此类推。如果对所有 $i = 1, 2, \dots, n$ 有 $\epsilon \in FIRST(X_{i})$ ，则将 $\epsilon$ 加入

#### Follow

对于非终结符 $A$ ，$FOLLOW(A)$ 是在某些句型后紧跟在 $A$ 之后的终结符的集合（没有 $\epsilon$）

在预测分析时，若 $A \to \alpha$ ，当 $\alpha \overset{*}{\Rightarrow} \epsilon$ 时，$FOLLOW(A)$ 可以用于选择恰当的产生式

对于非终结符 $A$，$FOLLOW(A)$ 的计算为不断应用如下规则直至没有终结符可以加入

* 将 $\$$ 加入 $FOLLOW(S)$ ，其中 $\$$ 是标志输入的结束标记
* 如果存在产生式 $A \to \alpha B\beta$ ，则 $FIRST(\beta)$ 中除 $\epsilon$ 以外的符号都在 $FOLLOW(B)$
* 如果存在产生式 $A \to \alpha B$ 或存在产生式 $A \to \alpha B \beta$ 且 $\epsilon \in FIRST(\beta)$ ，则 $FOLLOW(A)$ 所有符号都在 $FOLLOW(B)$ 中

