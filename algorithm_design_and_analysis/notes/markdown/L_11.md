[![white.png](https://i.loli.net/2019/04/11/5cae134487910.png)](https://github.com/i1123581321/NJU-open-resource)

# Graph Traversal

## Warm up

### Graph

图可以表示某集合中的元素之间的二元关系。

给定图 $G = (V, E)$ ，$V$ 是节点集，$E \subseteq V \times V$ 是结点间的某种二元关系。若 $E$ 是对称关系，则称 $G$ 为**无向图**，否则 $G$ 为**有向图** 

用于表示图的数据结构有两种：

* 邻接表：每个节点维护一个链表，存放其邻居
* 邻接矩阵：矩阵 $A_{n \times n}$ 的元素 $A[i,j]$ 是一个布尔值，表示是否存在一条由节点 $i$ 指向节点 $j$ 的边

邻接表和邻接矩阵都只能描述非对称关系，描述无向图时采用对称有向图

### Outline of DFS and BFS

深度优先遍历：递归

```pseudocode
dfs(G, v)
	Mark v as "discovered"
	For each vertex w that edge vw is in G
		if w is undiscovered
			dfs(G, w)
		otherwise
			"Check" vw without visiting w
	Mark v as "finished"
```

广度优先遍历：队列

```pseudocode
bfs(G, s)
	Mark s as "discovered"
	enqueue(pending, s)
	while(pending is nonempty)
		dequeue(pending, v)
		For each vertex that edge vw is in G
			if w is "undiscovered"
				Mark w as "discovered"
				enqueue(pending, w)
		Mark v as "finished"
```

### Finding Connected Components

基于深度优先遍历，找到图中所有连通分支

若图中有 $n$ 个节点和 $m$ 条边，时间复杂度为 $\Theta(m+n)$

## Traversal

### Visits on a vertex

根据图遍历中一个节点被访问的不同状态，可以将其染成三种颜色

* 白色：尚未被遍历到
* 灰色：已经遍历到，但是对其的遍历尚未结束。（正在处理其邻居节点）
* 黑色：遍历结束。（所有邻居节点已经被处理完）

显然节点在遍历过程中颜色变化为 白色 $\to$ 灰色 $\to$ 黑色，且不会回退

遍历开始时节点均是白色。第一次访问时由白变灰，之后的多次访问中保持灰色，在最后一次访问后变为黑色

### Depth-First Search Skeleton

首先为了能够在图不连通时遍历所有节点，需要一个 **wrapper** 以调度算法确保在某个连通分支遍历后能遍历下一个连通分支

DFS-WRAPPER(G)

```pseudocode
Color all nodes WHITE
foreach node v in G do
	if v.color == WHITE then
		DFS(v)
```

DFS(v)

```pseudocode
v.color := GRAY
<Preorder processiong of node v>
foreach neighbor w of v do
	if w.color == WHITE then
		<Exploratory processing of edge vw>
		DFS(w)
		<Backtrack processing of edge vw>
	else
		<Checking edge vw>
<Postorder processing of node v>
v.color := BLACK
```

在算法框架的不同位置（尖括号的语句）可插入不同的处理语句以解决具体问题

* 遍历前处理：当一个节点 $v$ 刚刚从白色变为灰色时
* 遍历中处理：
  * 遍历某邻居节点前
  * 遍历某邻居节点后
  * 处理之前已被遍历的邻居节点
* 遍历后处理：在节点递归遍历完成后，变为黑色前

只要限定这些处理包含常数个简单操作，深度优先的代价即为 $O(m + n)$，$n$ 为图 $G$ 中节点个数，$m$ 为边的条数

对用一个图算法，常常将一个代价为 $O(m+n)$ 的算法称作是**线性时间**的

### DFS search tree

Depth-First Search 的过程，会生成一颗树