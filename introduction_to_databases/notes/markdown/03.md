# 关系数据库系统

## 概述

关系数据库的优点

* 数据结构简单：二维表
* 使用方便
* 功能强
* 数据独立性高
* 理论基础深
* 可移植性好
* 标准化程度高
* 分布式
* 开放性

## RDBMS 衡量准则

初期（1974 年的 IFIP）提出了六条准则

* 提供高度数据独立性
* 提供严格数据视图
* 减轻 DBA 工作
* 建立理论基础
* 事务管理和文件管理相结合
* 操作对象是记录的集合，而非单个记录

1985 年提出了完全关系型的十二条准则

* 信息准则：关系数据库所有信息都能在表中唯一地表示，数据库的元信息也应当组织成关系形式
* 确保访问准则：通过表名，关键字，列名来访问数据库中每一个原子数据
* 空值的关系处理准则：系统有处理空值的能力，包括比较和表达式计算，统计计算等
* 基于资源管理的动态联机目录：数据库元信息和用户数据有相同的表现与操作形式
* 统一易用的数据子语言：支持数据定义，视图定义，数据操纵，完整性约束，授权机制，事务处理能力
* 视图更新准则
* 高级的插入，删除，修改
* 物理数据独立性
* 逻辑数据独立性
* 数据完整性准则：提供三类数据完整性约束的定义功能
* 分布独立性：数据分布的改变不影响原有应用
* 无损害原则

根据对上述原则的满足程度可以将 RDBMS 分为半关系型，基本关系型和完全关系型

## 关系代数

### 关系模型

关系模型中的术语有

* 关系：对应 RDBMS 的表
* 属性：对应表中的列
* 元组：对应表中的行
* schema：表头，即表的定义

#### 表

二维表由表框架（frame）和元组（tuple）组成，其中 frame 是多个有名的属性，每个属性有值域（domain），而表中每一行就是一个 tuple

属性数称为表的元数，元组数称为表的基数

二维表满足

* 元组个数有限
* 元组唯一
* 元组次序无关
* 元组分量原子性
* 属性名唯一
* 属性次序无关
* 分量的值域相同

则称为关系（relation），以关系为基本数据结构建立的模型称为关系模型，关系满足

* first normal form：不能有多值的域
* access rows by content only：行与列均无序，仅能通过内容而非序数访问行
* unique row：两个行不能所有分量都相等（关系是 tuple 的 set）

#### 键

能唯一最小标识元组的属性集称为键（key）

被用作标识元组的称为主键（primary key），其余为候选键。二维表至少有一个键

非形式化地来讲，key 是一系列属性的集合，满足

* 从设计的角度来说没有任意两个元组的 key 完全相同
* 不存在真子集满足上述属性

而 superkey 就是满足上述条件 1 而不满足条件 2 的属性集合

外键（foreign key）：如果表 A 中属性的集合 F 是表 B 的键，则称 F 为 A 的外键，A B 可以为同一张表（e. g. 职工表中键为工号，而每个职工有直属领导工号的属性，该属性就是该表的外键，同理可见外键不一定满足键的属性，多个职工可以有相同的直属领导）

#### 关系操作

关系操作的对象和结果都是关系，有五种基本的关系操作

* 选择元组
* 指定属性
* 合并两个关系
* 元组插入
* 元组删除

单张表的数据查询过程为

* 行选择：选择满足某些条件的元组
* 列指定：指定需要的属性

如果有超过一张表要查询，则将其合并为一张表再按单张表的操作进行查询

删除数据的最小单位是元组，基本流程是先根据逻辑确定要删除的元组，然后执行操作

插入数据是向关系内插入一个或多个新元组，删除和插入都只能同时操作一个关系

数据修改是修改满足逻辑的元组的某些分量，可以分解为删除-插入的组合

#### 空值操作

关系的主键不能出现空值

对于空值参与运算

* 算数表达式出现空值，则结果也为空值
* 逻辑运算出现空值，结果为假
* 统计计算中，不统计空值，如果对空集合操作 SUM/AVG/MIN/MAX 则结果为空值

#### 数据约束

有三类数据完整性约束

* 实体完整性约束：主键的属性不能有空值
* 参照完整性约束：外键要么是空值，要么是被引用表的某个存在的元组的主键
* 用户定义的数据约束

### 关系的表示

关系是元组的集合，元组是元组分量的集合

关系是属性域的笛卡尔积的子集
$$
R \subseteq D_{1} \times D_{2} \times \dots \times D_{n}
$$

### 关系操作的表示

关系模型上的增删改查可以分解为五种基本的操作，而由于其对象和结果都是关系，因此可以将基本操作看作集合上的运算，数据的操作可以表示为运算表达式

* 元组选择：选择运算
* 属性指定：投影运算
* 关系合并：笛卡尔积
* 元组插入：并运算
* 元组删除：差运算

定义两个表为相容表（compatible table），如果这两个表的表头相同（列数相同，每个属性值域相同，且意义相同）

传统集合运算有

* union $\cup$
* intersection $\cap$
* difference $-$

其中交并都满足结合律和交换律，且
$$
R \cap S = R - (R - S) = S - (S - R)
$$
关系的并/差运算满足两个操作关系必须相容，其结果的模式不变

关系的投影运算（projection）定义为略去某些列并重排其余列的操作，设 R 有 $n$ 个属性 $A_{1}, A_{2} \dots A_{n}$ ，在其中 $m$ 个属性 $B_{1}, B_{2} \dots B_{m}$ 上的投影记作
$$
\Pi_{B_{1}, B_{2} \dots B_{m}}(R)
$$
其结果关系元数变为 $m$，R 中每个元组取 $m$ 个指定属性的分量构成结果中的新元组，如果有重复的元组则要消除，即结果关系的基数小于等于 R 的基数。投影不满足交换律。

关系的选择运算（selection）为根据指定条件从关系中选出元组，记为
$$
\sigma_{F}(R)
$$
结果的模式不变，条件 F 可以由基本逻辑条件或复合逻辑条件构成。选择满足交换律。

数据查询就是单张表的投影和选择的结合 $\Pi_{A}(\sigma_{F}(R))$ 或者简写为 $\Pi_{A}\sigma_{F}(R)$

笛卡尔积可以表示两个关系的合并，满足交换律和结合律，如果有相同属性名，必须换名以避免冲突

则增删改查可以表示为

* 插入：$R \cup R^{\prime}$
* 删除：$R - R^{\prime}$
* 修改：$(R - R^{\prime}) \cup R^{\prime\prime}$
* 查询：$\Pi_{A}\sigma_{F}(R)$

### 扩充运算

交（intersection）满足两个操作关系必须相容，结果模式不变，可以用差实现

除运算 $R / S$ 需要满足 S 的表头是 R 的表头的子集，其结果模式是包含在 R 但不包含在 S 中的属性，结果元组是 S 中所有元组在 R 中对应的一个值，即设 $T = R/S$ ，则有 $head(T) = head(R) - head(S)$ ，且
$$
x \in T \iff \forall y \in S, (x, y) \in R
$$
显然 T 是满足 $S \times T \subseteq R$ 的最大集合

如果 $head(R) = \{A_{1}, A_{2} \dots A_{n}, B_{1}, B_{2} \dots B_{m} \}$ ，$head(S) = \{B_{1}, B_{2} \dots B_{m}\}$，则
$$
R / S = \Pi_{A_{1} \dots A_{n}}(R) - \Pi_{A_{1}\dots A_{n}}((\Pi_{A_{1}\dots A_{n}}(R) \times S) - R)
$$
联结（join）将两个关系按照某种条件合并，记为 $R \Join_{F} S$，结果的表头是参与运算的表的表头的并，有名冲突的话需要换名。联结条件可以是基本条件（R 中属性大于/小于/等于 S 中属性）或是基本条件用逻辑运算符连接形成的复合条件

显然 $R \Join_{F} S = \sigma_{F}(R \times F)$

自然联结（natural join）定义为按照关系中的共有属性进行连接，记为 $R \Join S$，结果中的元组均满足其同名属性值相等，元组中同名属性仅保留一份

> 外联结（outer join）为在自然联结基础上保留了不满足联结条件的元组的联结，如果对方表中没有满足共有属性相等的元组，则新元组中对方表的属性为空值，左外联为仅保留左表未满足条件元组的联结，空值出现在右表属性，右外联同理